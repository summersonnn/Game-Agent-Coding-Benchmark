1D-Chess is a simplified chess variant played on a 1x8 linear board. Two players compete using King, Knight, and Rook pieces to checkmate the opponent's King.

## Game Overview

The game is played on an 8-square linear board (positions 1-8). Each player starts with 3 pieces: King, Knight, and Rook. White pieces occupy squares 1-3, Black pieces occupy squares 6-8. White moves first.

## Board Setup

| Square | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **Piece** | K (King) | N (Knight) | R (Rook) | | | r (Rook) | n (Knight) | k (King) |
| **Side** | White | White | White | | | Black | Black | Black |

## Pieces and Movement

### King (K/k)
Can move exactly 1 square in either direction (left or right).

### Knight (N/n)
Can move exactly 2 squares in either direction (left or right). Knights jump over any pieces in the way.

### Rook (R/r)
Can move any number of squares in either direction (left or right). Cannot jump over pieces - blocked by the first piece in its path.

## Move Notation

Moves use the format: `[Piece][FromSquare][Capture?][ToSquare]`

- **Regular move**: `N24` - Knight moves from square 2 to square 4
- **Capture**: `R3x6` - Rook at square 3 captures the piece at square 6

## Game Rules

### Check
A King is in check when it is attacked by an opponent's piece.

### Checkmate (Win)
A player wins by checkmating the opponent's King. Checkmate occurs when:
1. The King is in check (under attack), AND
2. There is no legal move to escape check (no blocking, capturing the attacker, or moving the King to safety)

### Stalemate (Draw)
A draw occurs if a player is NOT in check but has no legal moves available.

### Threefold Repetition (Draw)
A draw occurs if the same board position is repeated 3 times during the game.

### Insufficient Material (Draw)
A draw occurs if only Kings remain on the board (no checkmate is possible).

### Illegal Move
If a player makes an illegal move (invalid notation, moving into check, impossible move), they forfeit the game.

## Game Interface

Your agent must implement the following class:

```python
class OneDChessAgent:
    def __init__(self, name, color):
        """
        Initialize the agent.
        
        Args:
            name: str - The agent's name (e.g., "Agent-1")
            color: str - 'W' for White or 'B' for Black
        """
        self.name = name
        self.color = color

    def make_move(self, board, move_history):
        """
        Decide the next move based on the current board state.
        
        Args:
            board: list[str] - 8-element list representing the board.
                   Index 0 = Square 1, Index 7 = Square 8.
                   Pieces: 'K','N','R' (White), 'k','n','r' (Black), '' (empty)
                   
            move_history: list[str] - List of all moves played so far.
                   Example: ["N24", "n75", "R36", "rx63"]
                   
        Returns:
            str: Move in notation format.
                 Regular move: "[Piece][From][To]" e.g., "N24"
                 Capture: "[Piece][From]x[To]" e.g., "R3x6"
        """
        # TODO: Implement your strategy
        return "K12"  # Example: King moves from 1 to 2
```

## Game Engine Implementation

The following code is the official game engine:

```python
class OneDChessGame:
    """
    1D Chess game engine.
    Board: 8 squares (index 0-7, displayed as 1-8 to players)
    Pieces: K/N/R (White), k/n/r (Black), '' (empty)
    """
    
    WHITE = 'W'
    BLACK = 'B'
    
    def __init__(self):
        # Board index 0-7 maps to squares 1-8
        # Starting position: White K(0), N(1), R(2), Black r(5), n(6), k(7)
        self.board = ['K', 'N', 'R', '', '', 'r', 'n', 'k']
        self.current_turn = self.WHITE
        self.move_history = []
        self.position_history = []  # For threefold repetition
        self._record_position()
    
    def _record_position(self):
        """Record current position for repetition detection."""
        pos = (tuple(self.board), self.current_turn)
        self.position_history.append(pos)
    
    def _is_white_piece(self, piece):
        return piece in ('K', 'N', 'R')
    
    def _is_black_piece(self, piece):
        return piece in ('k', 'n', 'r')
    
    def _is_own_piece(self, piece, color):
        if color == self.WHITE:
            return self._is_white_piece(piece)
        return self._is_black_piece(piece)
    
    def _is_enemy_piece(self, piece, color):
        if piece == '':
            return False
        return not self._is_own_piece(piece, color)
    
    def _get_piece_type(self, piece):
        """Return piece type in uppercase."""
        return piece.upper() if piece else ''
    
    def _find_king(self, color):
        """Find the position of the King for the given color."""
        target = 'K' if color == self.WHITE else 'k'
        for i, piece in enumerate(self.board):
            if piece == target:
                return i
        return -1  # King not found (should not happen in valid game)
    
    def _get_valid_moves_for_piece(self, pos, ignore_check=False):
        """
        Get all valid destination squares for the piece at pos.
        Returns list of (to_pos, is_capture) tuples.
        """
        piece = self.board[pos]
        if not piece:
            return []
        
        color = self.WHITE if self._is_white_piece(piece) else self.BLACK
        piece_type = self._get_piece_type(piece)
        moves = []
        
        if piece_type == 'K':
            # King: move 1 square left or right
            for delta in [-1, 1]:
                to_pos = pos + delta
                if 0 <= to_pos < 8:
                    target = self.board[to_pos]
                    if not self._is_own_piece(target, color):
                        is_capture = self._is_enemy_piece(target, color)
                        moves.append((to_pos, is_capture))
        
        elif piece_type == 'N':
            # Knight: move exactly 2 squares, can jump
            for delta in [-2, 2]:
                to_pos = pos + delta
                if 0 <= to_pos < 8:
                    target = self.board[to_pos]
                    if not self._is_own_piece(target, color):
                        is_capture = self._is_enemy_piece(target, color)
                        moves.append((to_pos, is_capture))
        
        elif piece_type == 'R':
            # Rook: move any distance, blocked by pieces
            for direction in [-1, 1]:
                to_pos = pos + direction
                while 0 <= to_pos < 8:
                    target = self.board[to_pos]
                    if target == '':
                        moves.append((to_pos, False))
                    elif self._is_enemy_piece(target, color):
                        moves.append((to_pos, True))
                        break  # Can capture but not go further
                    else:
                        break  # Blocked by own piece
                    to_pos += direction
        
        if ignore_check:
            return moves
        
        # Filter moves that would leave own King in check
        valid_moves = []
        for to_pos, is_capture in moves:
            if self._is_move_safe(pos, to_pos, color):
                valid_moves.append((to_pos, is_capture))
        
        return valid_moves
    
    def _is_move_safe(self, from_pos, to_pos, color):
        """Check if making this move would leave the King in check."""
        # Simulate the move
        original_from = self.board[from_pos]
        original_to = self.board[to_pos]
        
        self.board[to_pos] = self.board[from_pos]
        self.board[from_pos] = ''
        
        # Check if King is in check after move
        in_check = self._is_in_check(color)
        
        # Undo the move
        self.board[from_pos] = original_from
        self.board[to_pos] = original_to
        
        return not in_check
    
    def _is_in_check(self, color):
        """Check if the given color's King is under attack."""
        king_pos = self._find_king(color)
        if king_pos == -1:
            return True  # King captured (shouldn't happen in normal play)
        
        enemy_color = self.BLACK if color == self.WHITE else self.WHITE
        
        # Check all enemy pieces for attacks on the King
        for pos in range(8):
            piece = self.board[pos]
            if piece and self._is_own_piece(piece, enemy_color):
                # Get moves ignoring check (to avoid infinite recursion)
                enemy_moves = self._get_valid_moves_for_piece(pos, ignore_check=True)
                for to_pos, _ in enemy_moves:
                    if to_pos == king_pos:
                        return True
        return False
    
    def _has_legal_moves(self, color):
        """Check if the given color has any legal moves."""
        for pos in range(8):
            piece = self.board[pos]
            if piece and self._is_own_piece(piece, color):
                if self._get_valid_moves_for_piece(pos):
                    return True
        return False
    
    def _is_insufficient_material(self):
        """Check if only Kings remain (draw by insufficient material)."""
        for piece in self.board:
            if piece and piece.upper() != 'K':
                return False
        return True
    
    def _is_threefold_repetition(self):
        """Check for threefold repetition."""
        if len(self.position_history) < 3:
            return False
        current_pos = self.position_history[-1]
        count = sum(1 for pos in self.position_history if pos == current_pos)
        return count >= 3
    
    def parse_move(self, move_str):
        """
        Parse move notation into (piece_type, from_pos, to_pos, is_capture).
        Returns None if invalid format.
        
        Format: [Piece][From][x?][To]
        Examples: "N24", "R3x6", "K12"
        """
        move_str = move_str.strip()
        if len(move_str) < 3:
            return None
        
        piece = move_str[0].upper()
        if piece not in ('K', 'N', 'R'):
            return None
        
        # Check for capture notation
        if 'x' in move_str.lower():
            parts = move_str[1:].lower().split('x')
            if len(parts) != 2:
                return None
            try:
                from_sq = int(parts[0])
                to_sq = int(parts[1])
                is_capture = True
            except ValueError:
                return None
        else:
            # Regular move: piece + from + to (e.g., "N24")
            if len(move_str) != 3:
                return None
            try:
                from_sq = int(move_str[1])
                to_sq = int(move_str[2])
                is_capture = False
            except ValueError:
                return None
        
        # Convert 1-8 notation to 0-7 index
        from_pos = from_sq - 1
        to_pos = to_sq - 1
        
        if not (0 <= from_pos < 8 and 0 <= to_pos < 8):
            return None
        
        return (piece, from_pos, to_pos, is_capture)
    
    def is_valid_move(self, move_str, color):
        """Validate a move for the given color."""
        parsed = self.parse_move(move_str)
        if not parsed:
            return False, "Invalid move notation"
        
        piece_type, from_pos, to_pos, is_capture = parsed
        
        # Check piece at from_pos
        piece = self.board[from_pos]
        if not piece:
            return False, f"No piece at square {from_pos + 1}"
        
        if not self._is_own_piece(piece, color):
            return False, "Cannot move opponent's piece"
        
        if self._get_piece_type(piece) != piece_type:
            return False, f"Piece at square {from_pos + 1} is not a {piece_type}"
        
        # Check if move is in valid moves
        valid_moves = self._get_valid_moves_for_piece(from_pos)
        for valid_to, valid_capture in valid_moves:
            if valid_to == to_pos:
                # Verify capture notation matches
                if is_capture != valid_capture:
                    if is_capture:
                        return False, "No piece to capture at destination"
                    else:
                        return False, "Must use capture notation (x) when capturing"
                return True, ""
        
        # Move not found in valid moves
        if self._is_in_check(color):
            return False, "Must escape check"
        return False, "Invalid move for this piece"
    
    def make_move(self, move_str, color):
        """
        Execute a move. Returns (success, message).
        """
        valid, error = self.is_valid_move(move_str, color)
        if not valid:
            return False, error
        
        parsed = self.parse_move(move_str)
        _, from_pos, to_pos, _ = parsed
        
        # Execute move
        self.board[to_pos] = self.board[from_pos]
        self.board[from_pos] = ''
        
        # Record move and position
        self.move_history.append(move_str)
        self._record_position()
        
        # Switch turn
        self.current_turn = self.BLACK if self.current_turn == self.WHITE else self.WHITE
        
        return True, ""
    
    def get_game_state(self):
        """
        Check the current game state.
        Returns: 'ongoing', 'white_wins', 'black_wins', 'draw_stalemate',
                 'draw_repetition', 'draw_material'
        """
        # Check for insufficient material
        if self._is_insufficient_material():
            return 'draw_material'
        
        # Check for threefold repetition
        if self._is_threefold_repetition():
            return 'draw_repetition'
        
        current = self.current_turn
        in_check = self._is_in_check(current)
        has_moves = self._has_legal_moves(current)
        
        if not has_moves:
            if in_check:
                # Checkmate
                return 'white_wins' if current == self.BLACK else 'black_wins'
            else:
                # Stalemate
                return 'draw_stalemate'
        
        return 'ongoing'
    
    def get_board_display(self):
        """Return a string representation of the board."""
        squares = "| " + " | ".join(str(i+1) for i in range(8)) + " |"
        pieces = "| " + " | ".join(p if p else '.' for p in self.board) + " |"
        return f"{squares}\n{pieces}"
```

## Competition Format

- **1 vs 1 Match**: Two agents compete across multiple games.
- **Alternating Colors**: Agents swap colors (White/Black) each game.
- **Scoring**:
  - Win: 1 Point
  - Draw: 0.5 Points
  - Loss: 0 Points

**IMPORTANT**: Output ONLY the `OneDChessAgent` class definition and any necessary imports. Do NOT output the game engine code.