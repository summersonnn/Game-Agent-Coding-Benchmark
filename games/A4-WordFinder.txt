WordFinder is a 2-player word game where you must find a word that connects to the previous word.

## Game Overview

The game starts with a random word from the dictionary.
Players take turns finding a new word based on the previous word.
Each game lasts up to 50 rounds (100 individual turns, 50 per player).
The player with the higher score at the end of the game determines the outcome — but the margin of victory also matters (see Competition Format).

## Rules

1. **Letter Constraint**: The new word must CONTAIN the **first** and **last** letters of the previous word.
2. **Position Constraint**: The required letters (first/last of previous word) CANNOT be the first or last letters of the new word.
   - Example: Previous word "PUSH" (starts with 'P', ends with 'H').
   - You need a word containing 'P' and 'H'.
   - 'P' cannot be the first or last letter of your new word.
   - 'H' cannot be the first or last letter of your new word.
   - Valid: "ACCOMPLISHMENT" (contains 'P' and 'H', neither is at start/end).
   - Invalid: "POINT" (starts with 'P').
   - Invalid: "HELP" (ends with 'P', starts with 'H').
3. **Length Constraint**: Your word's length CANNOT equal the previous word's length.
   - Example: If previous word is "TELEPHONE" (9 letters), you cannot use a 9-letter word.
   - Valid: "ACCOMPLISHMENT" (14 letters != 9).
   - Invalid: "SUPERHERO" (9 letters = 9).
4. **Uniqueness**: A word can never be repeated in the game (by either player).
5. **Dictionary**: The word must be a valid English word (present in the game's dictionary).

## Scoring

- **Base Points**: You gain points equal to the **length** of your valid word.
- **Hyphen Penalty**: Words containing a hyphen ("-") get **half points** (length / 2).
  - Example: "MOTHER-IN-LAW" (13 letters) = 13 / 2 = **6 base points**
- **Consecutive Letter Bonus**: If the two required letters (first and last of the previous word) appear **consecutively** in your word, your base points are **multiplied by 2**!
  - Example: Previous word "PUSH" (requires 'P' and 'H').
  - Word "SHEPHERD" contains "PH" consecutively -> 8 letters x 2 = **16 points**
  - Word "TELEPATHY" contains 'P' and 'H' but not consecutively -> **9 points** (no bonus)
  - The letters can appear in either order: "PH" or "HP" both trigger the bonus.
  - The 2x bonus is applied AFTER the hyphen penalty if applicable.

## Partial Move (Last Resort)

If you believe there is NO valid word that contains BOTH required letters, you have a fallback option:

- **Partial Move**: Play a word that contains only ONE of the required letters (not at start/end position).
  - The game continues (does NOT end).
  - You receive **NEGATIVE points** (a penalty based on word length).
  - Example: Previous word "QUIZ" (requires 'Q' and 'Z'). No word has both? Play "LIQUID" (contains 'Q' but not 'Z').
    - You lose points, but the game continues.

**IMPORTANT**:
- This is a LAST RESORT when no valid word exists.
- If you play a partial move when a valid word WAS available, you're throwing away points unnecessarily.
- If your word contains NEITHER required letter (or has them at start/end), it's treated as an invalid move.

## Accessing the Word Dictionary

**CRITICAL**: The game environment provides a global function `load_words()` that returns a set of all valid words (lowercase).

You MUST use this function to access the dictionary:

```python
class WordFinderAgent:
    def __init__(self, name):
        self.name = name
        self.dictionary = load_words()  # Returns a set of lowercase words
```

**DO NOT** hardcode your own word list. **DO NOT** try to load from a file path yourself. The `load_words()` function is already available in the game environment.

## Competition Format

- 1 vs 1 match, multiple games per match.
- Starting agent is randomized each game.
- Each game lasts up to 50 rounds (100 individual turns).

### Match Points (Primary Metric)

Points depend on the **in-game score margin** between the two players at game end.
Two thresholds are derived from `max_rounds = 50`:
- **Decisive-win threshold:** `2 × max_rounds = 100`
- **Draw threshold:** `max_rounds = 50`

| Margin | Outcome | Winner pts | Loser pts |
|--------|---------|-----------|----------|
| ≥ 100 | Decisive win | **3** | **0** |
| 50 – 99 | Narrow win | **2** | **0.5** |
| < 50 (or exact tie) | Draw | **1** | **1** |

### Tie-Breaker Score (Secondary Metric)
- **Win (decisive or narrow):** Winner gets +margin, loser gets −margin.
- **Draw:** 0 for both players.

### Error Handling
| Failure Type | Consequence |
| --- | --- |
| make_move() Crash | Random valid move played; game continues. |
| Initialization Crash | Immediate game forfeit (only the current game). Opponent wins with max score. |
| Move Timeout | Random valid move played; game continues. (Default 1.0s) |
| Invalid Move | Random valid move played; game continues. |

## WordFinderAgent Interface

```python
import random


class WordFinderAgent:
    """
    Your agent implementation goes here.
    """
    def __init__(self, name):
        """
        Initialize your agent.
        """
        self.name = name
        self.dictionary = load_words()  # Load the full word dictionary

    def make_move(self, current_word, word_history):
        """
        Called when it's your turn.

        Parameters:
        -----------
        current_word : str
            The word played by the opponent (or the starting word).

        word_history : set
            A set of all words that have been used so far in the game (by both players).
            This includes the current_word and all previous words.
            You MUST NOT return a word that is in this set.

        Returns:
        --------
        str
            Your word choice.
        """
        # TODO: Implement your strategy
        # 1. Find the required characters from current_word (first and last char)
        # 2. Search for a valid word that:
        #    - Contains those characters
        #    - Does not have them at start or end
        #    - Has a DIFFERENT length than current_word
        #    - Is NOT in word_history (very important!)
        #    - Is in self.dictionary
        # 3. Optimize for length (points) and difficulty for opponent

        return "example"
```

### Agent Coding Requirements
- **No Internal Imports**: Do not import any game engine files, match runners, or project-specific modules. Use only standard library imports.
- **Isolation**: Your agent must be completely self-contained. Do not assume any specific file structure or directory hierarchy.
- **Class-Only Output**: Output ONLY the agent class and necessary standard imports. Do not include testing code, game logic outside the class, or example usage.
- **No Broad Exception Handlers**: Do not wrap the body of `make_move()` in a broad exception handler such as `except Exception:`, `except BaseException:`, or a bare `except:`. The engine uses `signal.alarm` to enforce move time limits; broad catches will swallow the timeout exception and cause the match to hang.


**IMPORTANT**: Output ONLY the WordFinderAgent class definition and any additional imports you need (random is already available). Do NOT output the entire game code.

## Strategy Tips

1. **Hunt for Bonuses**: Look for words with the required letters appearing consecutively - a 2x multiplier is huge!
2. **Avoid Hyphens**: Words with hyphens get only half points.
3. **Choose long words**: Longer words give more base points.
4. **Pre-compute When Possible**: Build lookup tables in `__init__` (runs once, not timed) rather than searching the full dictionary in `make_move` (runs every turn, timed).
5. **Use word_history**: The game provides you with the complete history of used words. Check against it to avoid penalties.
6. **Defensive Play**: Avoid leaving the opponent with easy letters (common letters like 'E', 'S' at start/end of your word).
7. **Offensive Play**: Try to force the opponent into a situation where they have to use difficult letters.
8. **Partial Move Fallback**: If absolutely NO valid word exists, use a partial move (one required letter) to avoid the -10 invalid penalty. It costs negative points but is better than an invalid move.
