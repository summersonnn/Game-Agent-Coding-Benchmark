Surround Morris is a 2-player territorial strategy game on a Nine Men's Morris board. Unlike the original game which uses "mills" (three in a row), this variant captures pieces by spatial surrounding using numerical superiority.

## Game Overview

The game is played on a 24-spot board consisting of three concentric squares connected at midpoints. Each player has 9 pieces (Black 'B' vs White 'W'). The goal is to eliminate all opponent pieces from the board.

## Board Layout

```
 0-----------1-----------2
 |           |           |
 |   3-------4-------5   |
 |   |       |       |   |
 |   |   6---7---8   |   |
 |   |   |       |   |   |
 9--10--11      12--13--14
 |   |   |       |   |   |
 |   |  15--16--17   |   |
 |   |       |       |   |
 |  18------19------20   |
 |           |           |
21----------22----------23
```

Spots are numbered 0-23. Lines between spots indicate adjacency (legal movement paths).

## Adjacency Graph

```python
ADJACENCY = {
    0: [1, 9],       1: [0, 2, 4],     2: [1, 14],
    3: [4, 10],      4: [1, 3, 5, 7],  5: [4, 13],
    6: [7, 11],      7: [4, 6, 8],     8: [7, 12],
    9: [0, 10, 21],  10: [3, 9, 11, 18], 11: [6, 10, 15],
    12: [8, 13, 17], 13: [5, 12, 14, 20], 14: [2, 13, 23],
    15: [11, 16],    16: [15, 17, 19],  17: [12, 16],
    18: [10, 19],    19: [16, 18, 20, 22], 20: [13, 19],
    21: [9, 22],     22: [19, 21, 23],  23: [14, 22],
}
```

**Node types by neighbor count:**
- **Corners (2 neighbors):** 0, 2, 6, 8, 15, 17, 18, 20, 21, 23, 3, 5
- **T-junctions (3 neighbors):** 1, 7, 9, 11, 12, 14, 16, 22
- **Crossroads (4 neighbors):** 4, 10, 13, 19

## The Capture Rule: "Overwhelm"

A piece is captured and removed when it satisfies BOTH conditions:
1. It has **zero empty adjacent spots** (completely blocked)
2. The number of **adjacent opponents is strictly greater** than the number of **adjacent friendlies**

```
IF (empty_neighbors == 0) AND (opponent_neighbors > friendly_neighbors) -> CAPTURED
```

**Examples:**

| Scenario | Opponents | Friendlies | Empty | Result |
|----------|:---------:|:----------:|:-----:|--------|
| Total Blockade | 4 | 0 | 0 | CAPTURED (4 > 0) |
| Overwhelmed | 3 | 1 | 0 | CAPTURED (3 > 1) |
| Heavily Defended | 1 | 3 | 0 | SAFE (1 < 3) |
| Stalemate | 2 | 2 | 0 | SAFE (2 = 2) |
| Escape Open | 3 | 0 | 1 | SAFE (has empty) |

## Gameplay Phases

### Phase 1: Placement
1. Board starts empty. Players alternate placing one piece at a time onto any vacant spot.
2. Black ('B') always places first.
3. Captures are checked after every placement. All opponent pieces satisfying the capture condition are removed immediately.
4. **Anti-suicide rule:** You cannot place a piece where it would be immediately captured. (The engine checks: place piece -> remove opponent captures -> if placed piece is still captured, the move is illegal.)
5. Phase ends when both players have placed all 9 pieces (18 total placements).

### Phase 2: Movement
1. Players alternate sliding one piece along a line to an adjacent empty spot.
2. **No flying:** Even with few pieces, you must slide to adjacent spots only.
3. Captures are checked after every move. Only opponent pieces can be captured during movement (the moved piece always has the vacated spot as an empty neighbor).
4. If a player has no legal moves, they pass (forced pass).

## Game End Conditions

The game ends during the movement phase when:
- A player has **0 pieces** on the board -> their opponent wins
- **200 movement turns** have elapsed -> draw
- **6 consecutive passes** -> draw

## Board Geometry & Capture Thresholds

| Position Type | Neighbors | To Capture (0 Friendlies) | To Capture (1 Friendly) |
|---------------|:---------:|:-------------------------:|:-----------------------:|
| Corner | 2 | 2 opponents | Impossible (1=1, tie) |
| T-junction | 3 | 3 opponents | 2 opponents (2 > 1) |
| Crossroad | 4 | 4 opponents | 3 opponents (3 > 1) |

## Game Engine Reference

The game engine provides a `SurroundMorrisGame` class with this state:

```python
class SurroundMorrisGame:
    board: list[str]          # 24 elements: '', 'B', or 'W'
    phase: str                # 'placement' or 'movement'
    pieces_in_hand: dict      # {'B': int, 'W': int}
    pieces_on_board: dict     # {'B': int, 'W': int}
    current_player: str       # 'B' or 'W'
    move_count: int           # movement turns elapsed

    def get_legal_placements(color) -> list[int]
        # Empty spots where placement is not suicide

    def get_legal_movements(color) -> list[tuple[int, int]]
        # All (from_spot, to_spot) pairs

    def is_captured(spot, board) -> bool
        # Check capture condition for piece at spot
```

## Error Codes Reference

### Placement Errors
| Code | Meaning |
|------|---------|
| `INVALID_SPOT_OOB` | Spot not in [0, 23] |
| `INVALID_SPOT_OCCUPIED` | Spot already has a piece |
| `INVALID_SUICIDE` | Placement would result in immediate capture |
| `INVALID_WRONG_PHASE` | Not in placement phase |
| `INVALID_OUTPUT` | Return value was not an integer |

### Movement Errors
| Code | Meaning |
|------|---------|
| `INVALID_SPOT_OOB` | Source spot not in [0, 23] |
| `INVALID_DEST_OOB` | Destination spot not in [0, 23] |
| `INVALID_NOT_YOUR_PIECE` | Source spot doesn't have your piece |
| `INVALID_DEST_OCCUPIED` | Destination spot is not empty |
| `INVALID_NOT_ADJACENT` | Source and destination are not adjacent |
| `INVALID_WRONG_PHASE` | Not in movement phase |
| `INVALID_OUTPUT` | Return value was not a (from, to) tuple |

## Error Handling

You get up to **3 attempts** per turn. On failure, you receive a `feedback` dict:

```python
{
    "error_code": str,        # one of the error codes above
    "error_message": str,     # human-readable description
    "attempted_move": ...,    # what you returned
    "attempt_number": int,    # 1-based attempt number
}
```

After 3 failures, a timeout, or a crash, the engine makes a random valid move for you.

## Implementation Task

Implement a `SurroundMorrisAgent` class that plays the game.

## SurroundMorrisAgent Interface

```python
import random

class SurroundMorrisAgent:
    """
    Your agent for Surround Morris.
    """
    def __init__(self, name: str, color: str):
        """
        Initialize your agent.

        Parameters:
        -----------
        name : str
            Your agent name (e.g., "Agent-1").
        color : str
            Your piece color: 'B' (Black) or 'W' (White).
        """
        self.name = name
        self.color = color

    def make_move(self, state: dict, feedback: dict | None = None):
        """
        Called each turn. Return your move based on the current game state.

        Parameters:
        -----------
        state : dict
            {
                "board": list[str],
                    # 24-element list. Each element is '', 'B', or 'W'.
                    # Index corresponds to spot number on the board.
                "phase": str,
                    # 'placement' or 'movement'
                "your_color": str,
                    # Your color: 'B' or 'W'
                "opponent_color": str,
                    # Opponent's color
                "pieces_in_hand": dict,
                    # {'B': int, 'W': int} - pieces not yet placed
                "pieces_on_board": dict,
                    # {'B': int, 'W': int} - pieces currently on the board
                "move_count": int,
                    # Number of movement turns elapsed (0 during placement)
            }

        feedback : dict or None
            None on first attempt. On retries after an invalid move:
            {
                "error_code": str,
                "error_message": str,
                "attempted_move": ...,
                "attempt_number": int,
            }

        Returns:
        --------
        During placement phase:
            int - the spot number (0-23) to place your piece

        During movement phase:
            tuple[int, int] - (from_spot, to_spot) to slide your piece
        """
        board = state["board"]
        phase = state["phase"]
        color = state["your_color"]
        opp = state["opponent_color"]

        if phase == "placement":
            # Find empty spots and pick one randomly
            empty = [i for i in range(24) if board[i] == '']
            return random.choice(empty) if empty else 0
        else:
            # Find legal moves: from your piece to adjacent empty spot
            moves = []
            for spot in range(24):
                if board[spot] != color:
                    continue
                for neighbor in ADJACENCY[spot]:
                    if board[neighbor] == '':
                        moves.append((spot, neighbor))
            return random.choice(moves) if moves else (0, 1)
```

**IMPORTANT**: Output ONLY the `SurroundMorrisAgent` class definition and any additional imports you need (`random` is already available). Do NOT output the entire game code. The `ADJACENCY` dict is available as a global variable at runtime.

## Strategy Tips

1. **Control crossroads (4 neighbors):** Spots 4, 10, 13, 19 are hardest to capture and give the most influence over adjacent pieces. Prioritize these during placement.
2. **Target corners (2 neighbors):** Corner pieces are easy to trap - only 2 enemies needed for capture with no friendly support.
3. **Build clusters:** Adjacent friendly pieces defend each other. Isolated pieces are vulnerable.
4. **Create pressure chains:** Position pieces to threaten multiple captures with a single move. Look for spots where moving in closes the last empty neighbor of an enemy AND creates numerical superiority.
5. **Preserve empty neighbors:** Keep escape routes for your pieces. A piece with at least one empty neighbor cannot be captured regardless of enemy count.
6. **Count before moving:** Before sliding, check if the destination closes gaps around your own pieces that might make them vulnerable.
7. **Placement phase is critical:** The opening 18 placements determine the entire board structure. Fight for central positions while disrupting opponent clusters.
8. **Anti-suicide awareness:** During placement, the engine rejects moves where your piece would be immediately captured (after opponent captures resolve). Use this knowledge - you can safely place next to enemies if you'll also trigger a capture that frees your piece.

## Competition Format

- 1 vs 1 match.
- Multiple games per match, alternating starting color.
- Win = 1 point, Draw = 0.5 points each.
- Cumulative score determines the winner.
