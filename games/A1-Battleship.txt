Battleship is played in two main phases: ship placement and bombing.

# PLACEMENT PHASE

During the placement phase, you must strategically position your ships on the grid. Ships can only be placed either horizontally or vertically—diagonal or intersecting placements are not allowed.

**Ship Placement Rules:**
- Each ship must be placed entirely within the board boundaries
- Ships cannot overlap or intersect with each other
- Ships can only be oriented horizontally or vertically (not diagonally)
- You get a single attempt to place each ship correctly
- If the attempt fails (invalid placement, timeout, or crash), the ship will be placed randomly as a penalty

**Placement State Dictionary:**
When it's your turn to place a ship, you'll receive a state dictionary with:
- `phase`: 'placement'
- `board_size`: The size of the board (e.g., 8)
- `ships_to_place`: List of ship lengths still to be placed (e.g., [5, 4, 3])
- `ships_placed`: Number of ships already successfully placed
- `my_board`: Current state of your board (2D list with 'O' for empty, 'S' for ship)

**Expected Response Format for Placement:**
Return a dictionary with:
```python
{
    'ship_length': int,              # Length of the ship being placed (must match first in ships_to_place)
    'start': (row, col),             # Starting coordinates (0-indexed)
    'orientation': 'horizontal'      # 'horizontal' or 'vertical'
}
```

Once both players have set their ships, the bombing phase begins.

# BOMBING PHASE

The maximum number of moves in a match is equal to the area of the game board multiplied by 2 (e.g., for an 8x8 board, the limit is 128 moves). If the match does not end within this limit, it results in a draw.

**Move Performance:**
Efficient decision-making is critical. If an agent takes too long to respond during any phase (placement or bombing), a random fallback action will be executed as a penalty to ensure the match continues.

**Scoring System:**
- **Win**: 3 points
- **Draw**: 1 point
- **Loss**: 0 points

**Secondary Score (Tie-breaker):**
In addition to points, a secondary "score" is calculated based on the winning side's remaining ship segments.
- If you win, your score is the total number of occupied cells (ships) remaining on your board.
- If you lose, your score is the negative of the winner's remaining ship segments (e.g., if the winner has 5 segments left, you get -5).
- If the game is a draw, both players receive a score of 0 for that round.

Players take turns guessing the coordinates of the opponent's ships. If a shot misses, the turn passes to the other player. If it hits, the player gets another attempt provided that it wasn't hit before (i.e. you cannot 'farm' extra turns by hitting the same spot). Targeting any already-targeted cell (whether it was a HIT or a MISS previously) is a waste of a move: it will be reported as a 'MISS' and the turn will pass. The game ends when one player loses all their ships, making the opponent the winner, or when the move limit is reached.

A key part of the game's strategy lies in making smart bombing decisions. For instance, after scoring a hit, it's wise to target adjacent cells—but do so with awareness that ships are always in straight lines, not crosses or irregular shapes.

Additionally, because the number and sizes of the ships are known before the bombing phase begins, players can deduce which ships have been sunk based on hit patterns. They can also avoid targeting certain grid areas when it's clear no remaining ship can logically fit there. Keep track of missed shots to avoid wasting shots on the same target.

**Bombing State Dictionary:**
During the bombing phase, you'll receive a state dictionary with:
- `phase`: 'bombing'
- `board_size`: The size of the board (e.g., 8)
- `last_shot_result`: 'HIT' or 'MISS' feedback from YOUR previous shot (Available even if your last turn ended with a MISS)
- `last_shot_coord`: (row, col) of YOUR previous shot (None on first turn)
- `turn_continues`: True if you get another shot (after a hit), False otherwise
- `shot_history`: A chronologically ordered list of your previous shots, where each entry is a dictionary: `{'coord': (row, col), 'result': 'HIT'|'MISS'}`

**Expected Response Format for Bombing:**
Return a dictionary with:
```python
{
    'target': (row, col)             # Coordinates to bomb (0-indexed)
}
```
### Error Handling
| Failure Type | Consequence |
| --- | --- |
| make_move() Crash | Random valid move played; game continues. |
| Initialization Crash | Immediate game forfeit. Opponent wins with max score. |
| Move Timeout | Random valid move played; game continues. |
| Invalid Move | Random valid move played; game continues. |

# AGENT IMPLEMENTATION

You'll receive the game's source code, but the implementation of the BattleshipAgent will be empty. Your task is to develop your own algorithms and strategies to build the BattleshipAgent class. Your agent will compete head-to-head against another AI-generated agent. Ensure that your agent adheres to the game rules and is capable of playing effectively.

### Agent Coding Requirements
- **No Internal Imports**: Do not import any game engine files, match runners, or project-specific modules. Use only standard library imports.
- **Isolation**: Your agent must be completely self-contained. Do not assume any specific file structure or directory hierarchy.
- **Single Class Implementation**: Do not implement any class other than the one provided in the starter code.
- **Class-Only Output**: Output ONLY the agent class and necessary standard imports. Do not include testing code, game logic outside the class, or example usage.
- **No Broad Exception Handlers**: Do not wrap the body of `make_move()` in a broad exception handler such as `except Exception:`, `except BaseException:`, or a bare `except:`. The engine uses `signal.alarm` to enforce move time limits; broad catches will swallow the timeout exception and cause the match to hang.



IMPORTANT: Output ONLY the BattleshipAgent class definition and any additional imports you need (beyond random and collections which are already available). Do NOT output the entire game code.

Certain pieces of information are essential for your agent, such as:

BOARD_SIZE = 8
SHIPS = [5, 4, 3]

This indicates that the game board is a 8x8 grid, and each player has three ships: one of length 5, one of length 4 and another of length 3. These variables are sent as parameters to your BattleshipAgent agent when constructing.

You are expected to write a working BattleshipAgent code that plays smartly.

```python

import random
import os
import time
from collections import deque

# --- Game Configuration ---
BOARD_SIZE = 8
SHIPS = [5, 4, 3]
NUM_GAMES = 5
# --- Board Representations ---
EMPTY = 'O'
SHIP = 'S'
HIT = 'X'
SUNK = '#'
MISS = 'M'

class BattleshipGame:
    """ Manages the state and rules of the game. """
    def __init__(self, size, ships):
        self.size = size
        self.ships = ships

    def _create_empty_board(self):
        return [[EMPTY for _ in range(self.size)] for _ in range(self.size)]

    def is_game_over(self, ships_board):
        """Checks if all ships on a given board have been sunk."""
        return not any(SHIP in row for row in ships_board)

# -------------------------------------------------------------------------------
class BattleshipAgent:
    """
    Your agent implementation goes here.
    Implement smart placement and bombing logic to beat your opponent.
    """
    def __init__(self, name, board_size, ships):
        self.name = name
        self.board_size = board_size
        self.ships = ships
        # TODO: Initialize your agent's state here

    def make_move(self, state, feedback):
        """
        Handles both placement and bombing phases based on state['phase'].

        Parameters:
        - state: Dictionary containing game state (see phase-specific documentation above)
        - feedback: Always None (reserved for future use)

        Returns:
        - During placement phase: Dictionary with 'ship_length', 'start', and 'orientation'
        - During bombing phase: Dictionary with 'target'

        Examples:

        # Placement phase
        if state['phase'] == 'placement':
            return {
                'ship_length': 5,
                'start': (0, 0),
                'orientation': 'horizontal'
            }

        # Bombing phase
        if state['phase'] == 'bombing':
            return {
                'target': (3, 4)
            }
        """
        # TODO: Implement your placement and bombing strategy
        if state['phase'] == 'placement':
            ship_length = state['ships_to_place'][0]
            # Random placement as example
            orientation = random.choice(['horizontal', 'vertical'])
            if orientation == 'horizontal':
                row = random.randint(0, self.board_size - 1)
                col = random.randint(0, self.board_size - ship_length)
            else:
                row = random.randint(0, self.board_size - ship_length)
                col = random.randint(0, self.board_size - 1)

            return {
                'ship_length': ship_length,
                'start': (row, col),
                'orientation': orientation
            }
        else:  # bombing phase
            row, col = random.randint(0, self.board_size-1), random.randint(0, self.board_size-1)
            return {
                'target': (row, col)
            }

```
